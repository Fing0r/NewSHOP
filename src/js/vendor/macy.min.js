 const masonryActiveClassName = 'masonryActive'
 const masonryItem = 'masonry__item'
 const specItemMore = 'specialists__item--more'
 const specItem = document.querySelectorAll('.specialists__item')
 const specItemVisible = document.querySelectorAll('.specialists__item--visible')
 const specBtnMore = document.querySelector('.specialists__more')
 const specList = document.querySelector('.specialists__list')
 

 class Masonry {
   constructor(element, options = {}) {
     this.containerNode = element
     this.childrenNodes = element.children
     this.btnMore = element.parentElement.children[2]
     this.flag = 1

     this.widthElem = parseInt(getComputedStyle(this.childrenNodes[1]).getPropertyValue('max-width'))

     this.childrenData = Array.from(this.childrenNodes).map((childNode) => ({
       childNode,
     }))

     this.childrenData = this.childrenData.map((child) => ({
       ...child,
       height: child.childNode.offsetHeight,
     }))
     this.settings = {
       responsive: options.responsive || {
         0: {
           gap: 10,
           columns: 3,
           maxItem: 4,
         }
       }
     }

     this.settingsSizes = Object.keys(this.settings.responsive).map(
       (item) => Number(item)).sort((a, b) => a - b)

     this.resize = this.resize.bind(this)

     this.setEvents()
     this.setParameters()

     this.containerNode.classList.add(masonryActiveClassName)
   }

   setEvents() {
     this.debouncedResize = debounce(this.resize)
     window.addEventListener('resize', this.debouncedResize)
   }

   resize() {
     this.setParameters()
   }

   setParameters() {
     this.elemPadding = parseInt(getComputedStyle(this.containerNode).getPropertyValue('padding-left')) + parseInt(getComputedStyle(this.containerNode).getPropertyValue('padding-right'))
     this.contPadding = parseInt(getComputedStyle(this.containerNode.parentElement).getPropertyValue('padding-left')) + parseInt(getComputedStyle(this.containerNode.parentElement).getPropertyValue('padding-right'))

     const containerWidth = this.containerNode.offsetWidth + this.contPadding + getScrollBarWidth()
     this.setCurrentSettings(containerWidth)

     const widthItem = (this.widthElem > (this.containerNode.offsetWidth - this.elemPadding)) ? (this.containerNode.offsetWidth - this.elemPadding) : this.widthElem
     this.setWidth(widthItem)

     if ((this.childrenNodes.length > this.settings.maxItem) && (this.flag === 1)) {
       this.childrenData.forEach(child => {
         child.childNode.classList.remove(specItemMore)
       });
       for (let i = this.settings.maxItem; i < this.childrenNodes.length; i++) {
         this.childrenData[i].childNode.classList.add(specItemMore)
       }
       if ((this.settings.columns === 4)) {
         for (let i = 0; i < this.settings.maxItem; i++) {
           this.childrenData[i].childNode.style.bottom = 0
         }
       } else {
         for (let i = 0; i < this.settings.maxItem; i++) {
           this.childrenData[i].childNode.style.bottom = null
         }
       }
     } else {
       this.childrenData.forEach(child => {
         child.childNode.classList.remove(specItemMore)
         child.childNode.style.bottom = null
       });
     }

     if ((this.childrenNodes.length === this.settings.maxItem) && (this.flag === 1)) {
       specBtnMore.style.display = 'none'
     } else if ((this.childrenNodes.length > this.settings.maxItem) && (this.flag === 1)) {
       specBtnMore.style.display = 'block'
     }

     this.setSizeContainer()
     this.setPosition(widthItem)
   }

   setCurrentSettings(containerWidth) {
     let currentSize = 0
     this.settingsSizes.forEach((size) => {
       if (containerWidth >= size) {
         currentSize = size
       }
     })

     this.settings.columns = this.settings.responsive[currentSize].columns
     this.settings.maxItem = this.settings.responsive[currentSize].maxItem

     let gaps = (containerWidth - this.elemPadding - this.contPadding - this.widthElem * this.settings.columns) / (this.settings.columns - 1)
     this.settings.rowGap = this.settings.responsive[currentSize].gap
     this.settings.columnGap = (Math.abs(gaps) === Infinity) ? 0 : gaps
   }

   setWidth(widthItem) {
     this.childrenData.forEach((child) => {
       child.childNode.style.width = `${widthItem}px`
     })
   }

   setSizeContainer() {
     const heightColumns = new Array(this.settings.columns).fill(0)

     this.childrenData.forEach((child, i) => {
       if (!child.childNode.classList.contains(specItemMore)) {
         heightColumns[i % this.settings.columns] += child.height + this.settings.rowGap
       }
     })
     const maxHeightColumn = heightColumns.reduce((acc, size) => (size > acc) ? size : acc)
     this.containerNode.style.height = `${maxHeightColumn - this.settings.rowGap}px`
   }

   setPosition(widthItem) {
     const topSets = new Array(this.settings.columns).fill(0)

     this.childrenData = this.childrenData.map((child, i) => {
       const indexColumn = i % this.settings.columns
       const left = indexColumn * widthItem + this.settings.columnGap * indexColumn
       const top = topSets[indexColumn]
       topSets[indexColumn] += child.height + this.settings.rowGap

       return {
         ...child,
         left,
         top
       }
     })
     if (topSets.length === 2) {
       const containerWidth = this.containerNode.offsetWidth - this.contPadding - this.elemPadding
       let gapTwo = (containerWidth - this.widthElem * this.settings.columns) / 2
       for (let i = 0; i < this.childrenData.length; i += 2) {
         this.childrenData[i].left = this.childrenData[i].left + gapTwo;
       }
       for (let i = 1; i < this.childrenData.length; i += 2) {
         this.childrenData[i].left = this.childrenData[i].left - gapTwo;
       }
     }

     if ((this.childrenNodes.length <= 4) && (this.settings.columns === 4)) {
       this.childrenData.forEach((child) => {
         child.childNode.classList.remove(masonryItem)
         child.childNode.style = null
       })
     } else {
       this.childrenData.forEach((child) => {
         child.childNode.classList.add(masonryItem)
         child.childNode.style.transform = `translate3d(${child.left}px, ${child.top}px, 0)`
       })
     }
   }
 }


 function debounce(func, time = 100) {
   let timer
   return function (event) {
     clearTimeout(timer)
     timer = setTimeout(func, time, event)
   }
 }


 function getScrollBarWidth() {
   let inner = document.createElement('p');
   inner.style.width = "100%";
   inner.style.height = "200px";

   let outer = document.createElement('div');
   outer.style.position = "absolute";
   outer.style.top = "0px";
   outer.style.left = "0px";
   outer.style.visibility = "hidden";
   outer.style.width = "200px";
   outer.style.height = "150px";
   outer.style.overflow = "hidden";
   outer.appendChild(inner);

   document.body.appendChild(outer);
   let w1 = inner.offsetWidth;
   outer.style.overflow = 'scroll';
   let w2 = inner.offsetWidth;
   if (w1 == w2) w2 = outer.clientWidth;

   document.body.removeChild(outer);

   return (w1 - w2);
 }
